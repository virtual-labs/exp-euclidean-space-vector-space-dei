<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" href="./assets/css/bootstrap.min.css">
<title>Linear Algebra Virtual Lab</title>
<link rel = "icon" href = "https://www.vlab.co.in/images/logo.jpg" type = "image/x-icon">
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

<style type="text/css">
	
.responsive-three-column-grid {
    display:block;
    float: center;
    margin-top: 0;
}

.responsive-three-column-grid > * {
    padding:.1rem 1rem;
    margin: 0.5rem;
}

@media (min-width:768px) {
    .responsive-three-column-grid {
        display: grid;
        grid-auto-rows: 1fr;
        grid-template-columns: 1fr 1fr 1fr;
    }
}
.col1{
    border:2px solid crimson;
}
.col2{
    border:2px solid green;
}
.col3{
    border:2px solid #009;
}
.modelcol{
    display:block;
    float:center;
    background-color: antiquewhite;
    padding:1rem 2rem;
    text-align: center;
    border:2px solid darkorange;
}
.exphead{
	background-color: #87ceeb;
	align-content: center;
	text-align: center;
    margin-top: 0.5rem;
    margin-bottom: 0.5rem;
}
.linkhead{
    align-content: center;
    text-align: center;
    background-color: bisque;
    border: 2px solid brown;
}
.intro{
    display: block;
    text-align: center;
    font-size:20px;
    color: orangered;
}
canvas {
    display: block;
}
.next{
    background-color: #04AA6D;
    color: white;
    font-size: 18px;
    margin-top: 0.5rem;
    align-content: center;
    text-align: center;
    padding: 8px 16px;
    text-decoration: none;
    width:5rem;
    float:right;
}
.next:hover {
  background-color: #ada;
  color: black;
}
.previous{
    display: block;
    float:left;
    background-color: #04AA6D;
    color: white;
    font-size: 18px;
    margin-top: 0.5rem;
    align-content: center;
    text-align: center;
    padding: 8px 16px;
    text-decoration: none;
    width:5rem;
}
.previous:hover {
  background-color: #ada;
  color: black;
}

input{
    background-color: #edbb99;
    align-content: center;
    text-align: center;
    font-style:bold italic;
    font-size: 14px;
    color:white;
    border:.5px solid red;
    color: black;
}
input:hover{
    background-color: brown;
    color:white;
}
.plane{
    cursor: crosshair;
}
.boxhead{
    margin:0.5rem 0.5rem 0.5rem 0.5rem;
}
p{
    margin:0.5rem 0.5rem 0.5rem 0.5rem;
}

.stepbtn{
    display:inline-block;
    color:red;
    border:1px solid yellow;
    background: lightyellow;
    box-shadow: 0 0 5px -1px rgba(0,0,0,0.2);
    vertical-align:middle;
    width:6rem;
    padding: 5px;
    text-align: center;
    font-size: 22px;
    font-weight: bold;

}
</style>
</head>
<body>
    
    <p style="float: center; align-content:right;">
        <a href="./" class="previous">&laquo; Home</a>
        <a href="../experiment1/operations.html" class="next" >Next &raquo;</a>
    </p>
    <br><br><br>
    <h1 class="exphead">n-Dimensional Euclidean Space</h1>
    <h2 class="linkhead">Link (One-to-One Correspondence) between Plane, R<sup>2</sup> and Vectors at Origin</h2>
	<div class="responsive-three-column-grid">
    
    <div class="col1" style="background-color:#fbeee6;">
        <div class="stepbtn">Step-1</div>
    	<h3 class="boxhead" style="color:darkred; background-color: #fadbd8; text-align: center; font-size: 25px;">1. Points on Plane</h3>
        <p style="background-color: #e8f5e9">(<span style="font-weight: bold;">Plane: </span> It is not a well defined term. It can be understood as a flat surface like top of a table that extends indefinitely in all the directions.)</p>
        <p style="font-weight: bold; color:red;">Pick a point by clicking on plane given below</p>
         <canvas class="plane" id="graphcanvas" width="250" height="250"></canvas>
         <p id="note1" style="color:blue;"></p>

    </div>
    <div class="col2" style="background-color:#fbeee6;">
        <div class="stepbtn">Step-2</div>
        <h3 class="boxhead" style="color:darkgreen; background-color:#e8f6f3; text-align:center; font-size:25px;">2. Geometric Visualization</h3>
        <p style="color:darkgreen;"><strong>Given pair of axes</strong></p>
        <canvas id="my-canvas" width="250" height="250"></canvas>
        <p id='printpoint1cords' style="font-size: 20px; color: green;"></p>
        <p id="note2" style="color:blue"></p>
        

    </div>
    <div class="col3" style="background-color:#fbeee6;">
    	<div class="stepbtn">Step-3</div>
        <h3 class="boxhead" style="color:#000099; background-color: #ccffff; text-align: center; font-size: 25px;">3. Vector Representation</h3>
        <canvas id="grphcnvs" width="250" height="250"></canvas>
        <p id="note3" style="color:blue"></p>

    </div>
    
</div>

<div class="modelcol">
    <h3 class="boxhead" style="color:firebrick; background-color: rgb(255,255,179); text-align: center; font-size: 25px;">MATH MODEL of Plane</h3>
    <p style="font-weight: bold; font-size: 24px;">R<sup>2</sup> = {(x , y) | x , y &isin; R}</p>
</div>
<p style="float: center; align-content:right;">
    <a href="./" class="previous">&laquo; Home</a>
<a href="../experiment1/operations.html" class="next" >Next &raquo;</a></p>
</body>


<script type="text/javascript" charset="utf-8">

var grid_size = 12;
var x_axis_distance_grid_lines = 10;
var y_axis_distance_grid_lines = 5;
var x_axis_starting_point = { number: 1, suffix: '' };
var y_axis_starting_point = { number: 1, suffix: '' };

var canvas = document.getElementById("my-canvas");

var ctx = canvas.getContext("2d");

var canvas_width = canvas.width;
var canvas_height = canvas.height;

var num_lines_x = Math.floor(canvas_width/grid_size);
var num_lines_y = Math.floor(canvas_height/grid_size);
        
// Draw grid lines along X-axis
for(var i=0; i<=num_lines_x; i++) {
    ctx.beginPath();
    ctx.lineWidth = 1;
    
    // If line represents X-axis draw in different color
    if(i == x_axis_distance_grid_lines) 
        ctx.strokeStyle = "#000000";
    else
        ctx.strokeStyle = "#dcdcdc";
    
    if(i == num_lines_x) {
        ctx.moveTo(0, grid_size*i);
        ctx.lineTo(canvas_width, grid_size*i);
    }
    else {
        ctx.moveTo(0, grid_size*i+0.5);
        ctx.lineTo(canvas_width, grid_size*i+0.5);
    }
    ctx.stroke();
}

// Draw grid lines along Y-axis
for(i=0; i<=num_lines_y; i++) {
    ctx.beginPath();
    ctx.lineWidth = 1;
    
    // If line represents X-axis draw in different color
    if(i == y_axis_distance_grid_lines) 
        ctx.strokeStyle = "#000000";
    else
        ctx.strokeStyle = "#dcdcdc";

    if(i == num_lines_y) {
        ctx.moveTo(grid_size*i, 0);
        ctx.lineTo(grid_size*i, window.canvas_height);
    }
    else {
        ctx.moveTo(grid_size*i+0.5, 0);
        ctx.lineTo(grid_size*i+0.5, canvas_height);
    }
    
    ctx.stroke();
}

// Translate to the new origin. Now Y-axis of the canvas is opposite to the Y-axis of the graph. So the y-coordinate of each element will be negative of the actual
ctx.translate(y_axis_distance_grid_lines*grid_size, x_axis_distance_grid_lines*grid_size);

// Ticks marks along the positive X-axis
for(i=1; i<(num_lines_y - y_axis_distance_grid_lines); i++) {
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#000000";

    // Draw a tick mark 6px long (-3 to 3)
    ctx.moveTo(grid_size*i+0.5, -3);
    ctx.lineTo(grid_size*i+0.5, 3);
    ctx.stroke();

    // Text value at that point
    ctx.font = '9px Arial';
    ctx.textAlign = 'start';
    ctx.fillText(x_axis_starting_point.number*i + x_axis_starting_point.suffix, grid_size*i-2, 15);
}

// Ticks marks along the negative X-axis
for(i=1; i<y_axis_distance_grid_lines; i++) {
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#000000";

    // Draw a tick mark 6px long (-3 to 3)
    ctx.moveTo(-grid_size*i+0.5, -3);
    ctx.lineTo(-grid_size*i+0.5, 3);
    ctx.stroke();

    // Text value at that point
    ctx.font = '9px Arial';
    ctx.textAlign = 'end';
    ctx.fillText(-x_axis_starting_point.number*i + x_axis_starting_point.suffix, -grid_size*i+3, 15);
}

// Ticks marks along the negative Y-axis
for(i=1; i<( x_axis_distance_grid_lines); i++) {
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#000000";

    // Draw a tick mark 6px long (-3 to 3)
    ctx.moveTo(-3, -grid_size*i+0.5);
    ctx.lineTo(3, -grid_size*i+0.5);
    ctx.stroke();

    // Text value at that point
    ctx.font = '9px Arial';
    ctx.textAlign = 'start';
    ctx.fillText(-y_axis_starting_point.number*i + y_axis_starting_point.suffix, 8, grid_size*i+3);
}

// Ticks marks along the positive Y-axis
for(i=1; i<(num_lines_x -x_axis_distance_grid_lines); i++) {
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#000000";

    // Draw a tick mark 6px long (-3 to 3)
    ctx.moveTo(-3, grid_size*i+0.5);
    ctx.lineTo(3, grid_size*i+0.5);
    ctx.stroke();

    // Text value at that point
    ctx.font = '9px Arial';
    ctx.textAlign = 'start';
    ctx.fillText(y_axis_starting_point.number*i + y_axis_starting_point.suffix, 8, -grid_size*i+3);
    
}

function drawCoordinates(x,y,bg){
    var pointSize = 3; // Change according to the size of the point.
   
    ctx.fillStyle = bg; 

    ctx.beginPath(); //Start path
    ctx.arc(x, y, pointSize, 0, Math.PI * 2, true); // Draw a point using the arc function of the canvas with a point structure.
    ctx.fill(); // Close the path and fill.
}

  
var gridsize = 12;
var x_distance_grid_lines = 10;
var y_distance_grid_lines = 5;
var x_starting_point = { number: 1, suffix: '' };
var y_starting_point = { number: 1, suffix: '' };

var cnvs = document.getElementById("graphcanvas");
//canvas.setAttribute("style", "position: absolute; x:0; y:0;");
//document.body.appendChild(canvas);

var context = cnvs.getContext("2d");

var cnvs_width = cnvs.width;
var cnvs_height = cnvs.height;

//context.fillRect(0, 0, canvas.width, canvas.height);
const coords = document.querySelector('.display-coords');
const getCoords = (event) => {
  const container = cnvs.getBoundingClientRect();
  const x1 = (event.clientX - 2*cnvs.offsetLeft)/25;
  const y1 = (event.clientY - 1.35*cnvs.offsetTop)/25;

  //coords.textContent = 'Picked a Point P. Now, you can see the coordinates of picked point.'
  //coords.textContent = `(${x1}, ${y1})`;
  drawCoords(x1*grid_size,y1*grid_size,'green');
  drawCoordinates(x1*grid_size,y1*grid_size,'green');
  document.getElementById('printpoint1cords').innerHTML=`(x , y) = (${x1} , ${-y1})`; 
  document.getElementById('note3').innerHTML=`<u style="color:#009;"><strong style="color:#009;">NOTE:</strong></u> The line segment joining the origin and the point directed towards the point is a vector at origin associated with the point.`;
  document.getElementById('note2').innerHTML=`<u style="color:#009;"><strong style="color:#009;">NOTE:</strong></u><ol><li>The values of x and y are approximate values.</li> <li>The values displayed for x & y are for the last choosen point.</li></ol>`; 
  document.getElementById('note1').innerHTML=`<u style="color:#009;"><strong style="color:#009;">NOTE:</strong></u> You are advised to REFRESH the page before picking another point on plane, although you can do so without refreshing the page.`; 
  drawCoordints(x1*grdsze,y1*grdsze,'green');
    cntxt.beginPath();
    cnvs_arrw(cntxt, 0*grdsze, 0*grdsze, x1*grdsze, y1*grdsze, 'green');
    cntxt.stroke();
    cntxt.lineWidth(3);
    cntxt.closePath();

     
    
     
};
cnvs.addEventListener('click', getCoords);
var num_x = Math.floor(cnvs_width/gridsize);
var num_y = Math.floor(cnvs_height/gridsize);

// Draw grid lines along X-axis
for(var i=0; i<=num_x; i++) {
    context.beginPath();
    context.lineWidth = 1;
    
    // If line represents X-axis draw in different color
    if(i == x_distance_grid_lines) 
        context.strokeStyle = "#dcdcdc";
    else
        context.strokeStyle = "#dcdcdc";
    
    if(i == num_x) {
        context.moveTo(0, gridsize*i);
        context.lineTo(cnvs_width, gridsize*i);
    }
    else {
        context.moveTo(0, gridsize*i+0.5);
        context.lineTo(cnvs_height, gridsize*i+0.5);
    }
    context.stroke();
}

// Draw grid lines along Y-axis
for(i=0; i<=num_y; i++) {
    context.beginPath();
    context.lineWidth = 1;
    
    // If line represents X-axis draw in different color
    if(i == y_distance_grid_lines) 
        context.strokeStyle = "#dcdcdc";
    else
        context.strokeStyle = "#dcdcdc";

    if(i == num_y) {
        context.moveTo(gridsize*i, 0);
        context.lineTo(gridsize*i, window.cnvs_height);
    }
    else {
        context.moveTo(gridsize*i+0.5, 0);
        context.lineTo(gridsize*i+0.5, cnvs_height);
    }
    
    context.stroke();
}

// Translate to the new origin. Now Y-axis of the canvas is opposite to the Y-axis of the graph. So the y-coordinate of each element will be negative of the actual
context.translate(y_distance_grid_lines*gridsize, x_distance_grid_lines*gridsize);



function drawCoords(x,y,bg){
    var pntSize = 3; // Change according to the size of the point.
   
    context.fillStyle = bg; // Red color

    context.beginPath(); //Start path
    context.arc(x, y, pntSize, 0, Math.PI * 2, true); //Draw a point using the arc function of the canvas with a point structure.
    context.fill(); // Close the path and fill.
}

  
var grdsze = 12;
var x_grid_lines = 10;
var y_grid_lines = 5;
var x_start = { number: 1, suffix: '' };
var y_start = { number: 1, suffix: '' };

var cns = document.getElementById("grphcnvs");
//canvas.setAttribute("style", "position: absolute; x:0; y:0;");
//document.body.appendChild(canvas);

var cntxt = cns.getContext("2d");

var cns_width = cns.width;
var cns_height = cns.height;

var nx = Math.floor(cns_width/gridsize);
var ny = Math.floor(cns_height/gridsize);

// Draw grid lines along X-axis
for(var i=0; i<=nx; i++) {
    cntxt.beginPath();
    cntxt.lineWidth = 1;
    
    // If line represents X-axis draw in different color
    if(i == x_grid_lines) 
        cntxt.strokeStyle = "#000000";
    else
        cntxt.strokeStyle = "#e9e9e9";

    if(i == nx) {
        cntxt.moveTo(0, grdsze*i);
        cntxt.lineTo(cns_width, grdsze*i);
    }
    else {
        cntxt.moveTo(0, grdsze*i+0.5);
        cntxt.lineTo(cns_height, grdsze*i+0.5);
    }
    cntxt.stroke();
}

// Draw grid lines along Y-axis
for(i=0; i<=ny; i++) {
    cntxt.beginPath();
    cntxt.lineWidth = 1;
    
    // If line represents X-axis draw in different color
    if(i == y_grid_lines) 
        cntxt.strokeStyle = "#000000";
    else
        cntxt.strokeStyle = "#e9e9e9";

    if(i == ny) {
        cntxt.moveTo(grdsze*i, 0);
        cntxt.lineTo(grdsze*i, window.cns_height);
    }
    else {
        cntxt.moveTo(grdsze*i+0.5, 0);
        cntxt.lineTo(grdsze*i+0.5, cns_height);
    }
    
    cntxt.stroke();
}

// Translate to the new origin. Now Y-axis of the canvas is opposite to the Y-axis of the graph. So the y-coordinate of each element will be negative of the actual
cntxt.translate(y_grid_lines*grdsze, x_grid_lines*grdsze);

// Ticks marks along the positive X-axis
for(i=1; i<(ny - y_grid_lines); i++) {
    cntxt.beginPath();
    cntxt.lineWidth = 1;
    cntxt.strokeStyle = "#000000";

    // Draw a tick mark 6px long (-3 to 3)
    cntxt.moveTo(grdsze*i+0.5, -3);
    cntxt.lineTo(grdsze*i+0.5, 3);
    cntxt.stroke();

    // Text value at that point
    cntxt.font = '9px Arial';
    cntxt.textAlign = 'start';
    cntxt.fillText(x_start.number*i + x_start.suffix, grdsze*i-2, 15);
}

// Ticks marks along the negative X-axis
for(i=1; i<y_grid_lines; i++) {
    cntxt.beginPath();
    cntxt.lineWidth = 1;
    cntxt.strokeStyle = "#000000";

    // Draw a tick mark 6px long (-3 to 3)
    cntxt.moveTo(-grdsze*i+0.5, -3);
    cntxt.lineTo(-grdsze*i+0.5, 3);
    cntxt.stroke();

    // Text value at that point
    cntxt.font = '9px Arial';
    cntxt.textAlign = 'end';
    cntxt.fillText(-x_start.number*i + x_start.suffix, -grdsze*i+3, 15);
}

// Ticks marks along the negative Y-axis
for(i=1; i<(nx - x_grid_lines); i++) {
    cntxt.beginPath();
    cntxt.lineWidth = 1;
    cntxt.strokeStyle = "#000000";

    // Draw a tick mark 6px long (-3 to 3)
    cntxt.moveTo(-3, grdsze*i+0.5);
    cntxt.lineTo(3, grdsze*i+0.5);
    cntxt.stroke();

    // Text value at that point
    cntxt.font = '9px Arial';
    cntxt.textAlign = 'start';
    cntxt.fillText(y_start.number*i + y_start.suffix, 8, -grdsze*i+3);
}

// Ticks marks along the positive Y-axis
for(i=1; i<(x_grid_lines); i++) {
    cntxt.beginPath();
    cntxt.lineWidth = 1;
    cntxt.strokeStyle = "#000000";

    // Draw a tick mark 6px long (-3 to 3)
    cntxt.moveTo(-3, -grdsze*i+0.5);
    cntxt.lineTo(3, -grdsze*i+0.5);
    cntxt.stroke();

    // Text value at that point
    cntxt.font = '9px Arial';
    cntxt.textAlign = 'start';
    cntxt.fillText(-y_start.number*i + y_start.suffix, 8, grdsze*i+3);
}

function drawCoordints(x,y,bg){
    var pSize = 3; // Change according to the size of the point.
   
    cntxt.fillStyle = bg; // Red color

    cntxt.beginPath(); //Start path
    cntxt.arc(x, y, pSize, 0, Math.PI * 2, true); // Draw a point using the arc function of the canvas with a point structure.
    cntxt.fill(); // Close the path and fill.
}
function cnvs_arrw(cntxt, fx, fy, tx, ty,cr) {
  var hl = 10; // length of head in pixels
  var dstx = tx - fx;
  var dsty = ty - fy;
  var ngl = Math.atan2(dsty, dstx);
  cntxt.fillstyle=cr;
  cntxt.moveTo(fx, fy);
  cntxt.lineTo(tx, ty);
  cntxt.lineTo(tx - hl * Math.cos(ngl - Math.PI / 6), ty - hl * Math.sin(ngl - Math.PI / 6));
  cntxt.moveTo(tx, ty);
  cntxt.lineTo(tx - hl * Math.cos(ngl + Math.PI / 6), ty - hl * Math.sin(ngl + Math.PI / 6));

}

</script>
</html>
